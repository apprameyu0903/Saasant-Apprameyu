package com.util;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;

public class DBUtilTest {

    // MockedStatic is used to mock static methods. It needs to be managed (created and closed).
    private MockedStatic<DriverManager> driverManagerMockedStatic;

    // These are the credentials hardcoded in DBUtil.java
    // For robust testing, these should match exactly.
    private static final String EXPECTED_URL = "jdbc:mysql://localhost:3306/billingsystem";
    private static final String EXPECTED_USER = "root";
    private static final String EXPECTED_PASSWORD = "@ppr@meY24";

    @BeforeEach
    void setUp() {
        // Initialize the static mock for DriverManager before each test.
        // This allows us to control the behavior of DriverManager.getConnection().
        driverManagerMockedStatic = Mockito.mockStatic(DriverManager.class);
    }

    @AfterEach
    void tearDown() {
        // Close the static mock after each test to restore the original DriverManager behavior
        // and prevent interference between tests.
        if (driverManagerMockedStatic != null) {
            driverManagerMockedStatic.close();
        }
    }

    @Test
    void testGetConnection_Success() {
        // Arrange: Create a mock Connection object that we expect to be returned.
        Connection mockConnection = mock(Connection.class);

        try {
            // Configure the static mock: when DriverManager.getConnection is called with
            // the specific URL, user, and password, it should return our mockConnection.
            driverManagerMockedStatic.when(() -> DriverManager.getConnection(EXPECTED_URL, EXPECTED_USER, EXPECTED_PASSWORD))
                    .thenReturn(mockConnection);

            // Act: Call the method under test.
            // This will trigger DBUtil class loading if not already loaded, running its static initializer.
            Connection actualConnection = DBUtil.getConnection();

            // Assert: Verify that the returned connection is the one we mocked.
            assertNotNull(actualConnection, "Connection should not be null.");
            assertSame(mockConnection, actualConnection, "Should return the mocked connection instance.");

            // Verify that DriverManager.getConnection was indeed called with the expected parameters.
            driverManagerMockedStatic.verify(() -> DriverManager.getConnection(EXPECTED_URL, EXPECTED_USER, EXPECTED_PASSWORD));

        } catch (SQLException e) {
            fail("SQLException was not expected in the success path: " + e.getMessage());
        } catch (ExceptionInInitializerError e) {
            // This error occurs if the static initializer block in DBUtil fails (e.g., JDBC driver class not found).
            // The mysql-connector-j dependency in pom.xml should prevent this for the driver.
            fail("DBUtil class failed to initialize. Check MySQL driver in test classpath and static block in DBUtil: " + e.getCause().getMessage());
        }
    }

    @Test
    void testGetConnection_ThrowsSQLException() {
        // Arrange: Define an SQLException that we expect DriverManager to throw.
        SQLException expectedSqlException = new SQLException("Mocked SQL Exception: Database connection failed.");

        try {
            // Configure the static mock: when DriverManager.getConnection is called, it should throw the defined SQLException.
            driverManagerMockedStatic.when(() -> DriverManager.getConnection(EXPECTED_URL, EXPECTED_USER, EXPECTED_PASSWORD))
                    .thenThrow(expectedSqlException);

            // Act & Assert: Call DBUtil.getConnection() and assert that it throws the expected SQLException.
            SQLException actualException = assertThrows(SQLException.class, () -> {
                DBUtil.getConnection();
            }, "DBUtil.getConnection() should re-throw the SQLException from DriverManager.");

            // Optionally, verify that the thrown exception is the exact instance we configured.
            assertSame(expectedSqlException, actualException, "The thrown SQLException should be the same instance we mocked.");
            assertEquals("Mocked SQL Exception: Database connection failed.", actualException.getMessage());

            // Verify that DriverManager.getConnection was called.
            driverManagerMockedStatic.verify(() -> DriverManager.getConnection(EXPECTED_URL, EXPECTED_USER, EXPECTED_PASSWORD));

        } catch (ExceptionInInitializerError e) {
            fail("DBUtil class failed to initialize: " + e.getCause().getMessage());
        }
        // No need to catch SQLException here as assertThrows handles it.
    }

    @Test
    void testDBUtilClassLoadsSuccessfully_EnsuringDriverLoads() {
       
        try {
            Class<?> dbUtilClass = Class.forName("com.util.DBUtil");
            assertNotNull(dbUtilClass, "DBUtil class should be loadable.");
        } catch (ClassNotFoundException e) {
            fail("DBUtil class itself was not found: " + e.getMessage());
        } catch (ExceptionInInitializerError e) {
            // This error indicates a failure within the static initializer block of DBUtil.
            // The cause would typically be the RuntimeException thrown by DBUtil if
            // Class.forName("com.mysql.cj.jdbc.Driver") fails.
            Throwable cause = e.getCause();
            String causeMessage = (cause != null) ? cause.getMessage() : "Unknown cause";
            fail("Static initializer of DBUtil failed, likely due to JDBC driver loading issue: " + causeMessage, e);
        }
    }
}

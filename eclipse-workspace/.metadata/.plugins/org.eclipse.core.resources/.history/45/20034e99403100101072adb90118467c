package com.service;

import com.dao.ProductDaoInterface;
import com.vo.ProductInfo;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Map;
import java.util.Scanner;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class BillingServiceTest {

    @Mock
    private ProductDaoInterface mockProductDao;

    @InjectMocks
    private BillingService billingService; // Uses new Scanner()

    private ProductInfo product1, product2;

    // Helper to simulate System.in for Scanner
    private void provideInput(String data) {
        InputStream stdin = System.in; // Save original System.in
        try {
            System.setIn(new ByteArrayInputStream(data.getBytes()));
            // BillingService creates its own Scanner.
            // Re-initialize BillingService to pick up the new System.in and inject mocks.
            billingService = new BillingService(); 
            try {
                // Inject the mock DAO using reflection as constructor is default
                java.lang.reflect.Field daoField = BillingService.class.getDeclaredField("prods");
                daoField.setAccessible(true);
                daoField.set(billingService, mockProductDao);

                // Inject a new Scanner that uses the modified System.in
                java.lang.reflect.Field scannerField = BillingService.class.getDeclaredField("sc");
                scannerField.setAccessible(true);
                scannerField.set(billingService, new Scanner(System.in)); // Use the new System.in

            } catch (NoSuchFieldException | IllegalAccessException e) {
                throw new RuntimeException("Failed to inject mocks into BillingService via reflection", e);
            }
        } finally {
           // System.setIn(stdin); // Restore original System.in - careful with test interactions
        }
    }


    @BeforeEach
    void setUp() {
        // These are template products that DAO might return
        product1 = new ProductInfo("P001", "Laptop", "High-end laptop", "pcs", 1200.0f, "Electronics", 18.0f);
        product2 = new ProductInfo("P002", "Mouse", "Wireless mouse", "pcs", 25.0f, "Electronics", 18.0f);
         // Reset System.in before each test that might use provideInput
        System.setIn(System.in);
    }

    @Test
    void billingService_addProductAndStop() {
        // Input: Product ID, Quantity, "N" (don't add more)
        String input = "P001\n2\nN\n";
        provideInput(input);

        when(mockProductDao.getProductById("P001")).thenReturn(product1);

        Map<String, ProductInfo> billedProducts = billingService.billingService();

        assertNotNull(billedProducts);
        assertEquals(1, billedProducts.size());
        assertTrue(billedProducts.containsKey("P001"));
        assertEquals(2, billedProducts.get("P001").getQuantity());
        assertEquals(product1.getProductName(), billedProducts.get("P001").getProductName());

        verify(mockProductDao).getProductById("P001");
    }

    @Test
    void billingService_addMultipleProducts() {
        // P001, Qty 1, Yes -> P002, Qty 3, No
        String input = "P001\n1\nY\nP002\n3\nN\n";
        provideInput(input);

        when(mockProductDao.getProductById("P001")).thenReturn(product1);
        when(mockProductDao.getProductById("P002")).thenReturn(product2);

        Map<String, ProductInfo> billedProducts = billingService.billingService();

        assertEquals(2, billedProducts.size());
        assertTrue(billedProducts.containsKey("P001"));
        assertEquals(1, billedProducts.get("P001").getQuantity());
        assertTrue(billedProducts.containsKey("P002"));
        assertEquals(3, billedProducts.get("P002").getQuantity());
    }

    @Test
    void billingService_productNotFoundThenAddProduct() {
        // P_NON_EXIST (not found), then P001, Qty 1, No
        String input = "P_NON_EXIST\nP001\n1\nN\n";
        provideInput(input);

        when(mockProductDao.getProductById("P_NON_EXIST")).thenReturn(null);
        when(mockProductDao.getProductById("P001")).thenReturn(product1);

        Map<String, ProductInfo> billedProducts = billingService.billingService();
        // Should print "Product not found!" for P_NON_EXIST

        assertEquals(1, billedProducts.size());
        assertTrue(billedProducts.containsKey("P001"));
        assertEquals(1, billedProducts.get("P001").getQuantity());
    }
    
    @Test
    void billingService_addSameProductMultipleTimes_updatesQuantity() {
        // P001, Qty 2, Yes -> P001, Qty 3, No
        String input = "P001\n2\nY\nP001\n3\nN\n";
        provideInput(input);

        when(mockProductDao.getProductById("P001")).thenReturn(product1); // Returns the same product template each time

        Map<String, ProductInfo> billedProducts = billingService.billingService();

        assertEquals(1, billedProducts.size());
        assertTrue(billedProducts.containsKey("P001"));
        assertEquals(2 + 3, billedProducts.get("P001").getQuantity()); // Quantity should be summed
    }


    @Test
    void subTotal_calculatesCorrectly() {
        // Simulate that billingService() was called and populated billedProducts
        // P001 (1200 * 1.18 = 1416) * 2 = 2832 -> This is total amount. Subtotal should be (unitPrice * quantity)
        // unitPrice = 1200, tax = 18%
        // For subTotal calculation, tax on product itself is *not* part of it, only sum of (unitPrice*qty)

        ProductInfo p1Billed = new ProductInfo(product1.getProductId(), product1.getProductName(), product1.getProductDescription(), product1.getUnit(), product1.getUnitPrice(), product1.getCategory(), product1.getTax());
        p1Billed.setQuantity(2); // Total = (1200 * 1.18) * 2. Subtotal contribution = 1200 * 2 = 2400
                                 // The ProductInfo.getTotalAmount includes tax on the item.
                                 // The BillingService.subTotal uses ProductInfo.getTotalAmount(). This means subTotal in BillingService *includes* product-level tax.
                                 // Let's clarify: subTotal as per ProductInfo.getTotalAmount means (UnitPrice + (UnitPrice * Tax/100)) * Quantity.

        ProductInfo p2Billed = new ProductInfo(product2.getProductId(), product2.getProductName(), product2.getProductDescription(), product2.getUnit(), product2.getUnitPrice(), product2.getCategory(), product2.getTax());
        p2Billed.setQuantity(1); // Total = (25 * 1.18) * 1. Subtotal contribution = 25 * 1 = 25

        // Manually populate billedProducts for testing subTotal, gstCalc, calcTotal
        // This requires reflection to set the private 'billedProducts' field in BillingService
        try {
            java.lang.reflect.Field billedProductsField = BillingService.class.getDeclaredField("billedProducts");
            billedProductsField.setAccessible(true);
            Map<String, ProductInfo> internalBilledProducts = (Map<String, ProductInfo>) billedProductsField.get(billingService);
            internalBilledProducts.clear(); // Clear from previous tests if any
            internalBilledProducts.put(p1Billed.getProductId(), p1Billed);
            internalBilledProducts.put(p2Billed.getProductId(), p2Billed);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            fail("Failed to set billedProducts via reflection", e);
        }
        
        // Product1: (1200 + 1200*0.18) * 2 = (1200 + 216) * 2 = 1416 * 2 = 2832
        // Product2: (25 + 25*0.18) * 1 = (25 + 4.5) * 1 = 29.5 * 1 = 29.5
        // Expected subTotal = 2832 + 29.5 = 2861.5
        float expectedSubTotal = p1Billed.getTotalAmount() + p2Billed.getTotalAmount();
        assertEquals(expectedSubTotal, billingService.subTotal(), 0.01);
    }

    @Test
    void gstCalc_calculatesCorrectly() {
        // Similar setup as subTotal_calculatesCorrectly
        ProductInfo p1Billed = new ProductInfo(product1.getProductId(), product1.getProductName(), product1.getProductDescription(), product1.getUnit(), product1.getUnitPrice(), product1.getCategory(), product1.getTax());
        p1Billed.setQuantity(2);
        ProductInfo p2Billed = new ProductInfo(product2.getProductId(), product2.getProductName(), product2.getProductDescription(), product2.getUnit(), product2.getUnitPrice(), product2.getCategory(), product2.getTax());
        p2Billed.setQuantity(1);

        try {
            java.lang.reflect.Field billedProductsField = BillingService.class.getDeclaredField("billedProducts");
            billedProductsField.setAccessible(true);
            Map<String, ProductInfo> internalBilledProducts = (Map<String, ProductInfo>) billedProductsField.get(billingService);
            internalBilledProducts.clear();
            internalBilledProducts.put(p1Billed.getProductId(), p1Billed);
            internalBilledProducts.put(p2Billed.getProductId(), p2Billed);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            fail("Failed to set billedProducts via reflection", e);
        }
        
        float subTotalVal = p1Billed.getTotalAmount() + p2Billed.getTotalAmount();
        float expectedGst = subTotalVal * 0.18f;
        assertEquals(expectedGst, billingService.gstCalc(), 0.01);
    }

    @Test
    void calcTotal_calculatesCorrectly() {
        ProductInfo p1Billed = new ProductInfo(product1.getProductId(), product1.getProductName(), product1.getProductDescription(), product1.getUnit(), product1.getUnitPrice(), product1.getCategory(), product1.getTax());
        p1Billed.setQuantity(2);
        ProductInfo p2Billed = new ProductInfo(product2.getProductId(), product2.getProductName(), product2.getProductDescription(), product2.getUnit(), product2.getUnitPrice(), product2.getCategory(), product2.getTax());
        p2Billed.setQuantity(1);

        try {
            java.lang.reflect.Field billedProductsField = BillingService.class.getDeclaredField("billedProducts");
            billedProductsField.setAccessible(true);
            Map<String, ProductInfo> internalBilledProducts = (Map<String, ProductInfo>) billedProductsField.get(billingService);
            internalBilledProducts.clear();
            internalBilledProducts.put(p1Billed.getProductId(), p1Billed);
            internalBilledProducts.put(p2Billed.getProductId(), p2Billed);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            fail("Failed to set billedProducts via reflection", e);
        }
        
        float subTotalVal = p1Billed.getTotalAmount() + p2Billed.getTotalAmount();
        float gstVal = subTotalVal * 0.18f;
        float expectedGrandTotal = subTotalVal + gstVal;

        assertEquals(expectedGrandTotal, billingService.calcTotal(), 0.01);
    }
}
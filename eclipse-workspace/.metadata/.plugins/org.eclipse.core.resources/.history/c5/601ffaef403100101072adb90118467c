package com.service;

import com.dao.CustomerDaoInterface;
import com.vo.CustomerDetails;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class CustomerServiceTest {

    @Mock
    private CustomerDaoInterface mockCustomerDao;

    @InjectMocks
    private CustomerService customerService; // Uses new Scanner() internally

    private CustomerDetails customer1;
    private CustomerDetails customer2;

    @BeforeEach
    void setUp() {
        customer1 = new CustomerDetails("C001", "Alice", "1112223330", "Wonderland");
        customer2 = new CustomerDetails("C002", "Bob", "4445556660", "Builderland");
    }

    // Helper to simulate System.in for Scanner
    private void provideInput(String data) {
        InputStream stdin = System.in;
        try {
            System.setIn(new ByteArrayInputStream(data.getBytes()));
            // CustomerService creates its own Scanner, so we need to re-initialize
            // or refactor CustomerService to accept a Scanner or Reader.
            // For this example, we'll test methods that don't rely heavily on complex Scanner interactions,
            // or assume simple inputs can be simulated.
            // A better approach is to make Scanner injectable.
             customerService = new CustomerService(); // Re-init with new System.in
             // Manually inject the mock DAO again if constructor re-initializes
             try {
                java.lang.reflect.Field daoField = CustomerService.class.getDeclaredField("customerDao");
                daoField.setAccessible(true);
                daoField.set(customerService, mockCustomerDao);

                java.lang.reflect.Field scannerField = CustomerService.class.getDeclaredField("sc");
                scannerField.setAccessible(true);
                scannerField.set(customerService, new Scanner(System.in));


            } catch (NoSuchFieldException | IllegalAccessException e) {
                throw new RuntimeException(e);
            }


        } finally {
            // System.setIn(stdin); // Restore original System.in - causes issues with other tests if not careful
        }
    }


    @Test
    void addCustomer_newCustomer_success() {
        String input = "C003\nNew User\n7778889990\nTestLocation\n";
        provideInput(input);

        when(mockCustomerDao.getCustomerById("C003")).thenReturn(null); // New customer
        when(mockCustomerDao.addCustomer(any(CustomerDetails.class))).thenReturn(true);

        CustomerDetails newCustomer = customerService.addCustomer();

        assertNotNull(newCustomer);
        assertEquals("C003", newCustomer.getCustomerId());
        assertEquals("New User", newCustomer.getCustomerName());
        verify(mockCustomerDao, times(1)).addCustomer(any(CustomerDetails.class));
    }

    @Test
    void addCustomer_existingCustomer_returnsExisting() {
        String input = "C001\n"; // Only ID needed if customer exists
        provideInput(input);

        when(mockCustomerDao.getCustomerById("C001")).thenReturn(customer1);

        CustomerDetails existingCustomer = customerService.addCustomer();

        assertNotNull(existingCustomer);
        assertEquals(customer1.getCustomerId(), existingCustomer.getCustomerId());
        assertEquals(customer1.getCustomerName(), existingCustomer.getCustomerName());
        verify(mockCustomerDao, never()).addCustomer(any(CustomerDetails.class)); // addCustomer should not be called
    }
    
    @Test
    void addCustomer_newCustomer_daoFailsToAdd() {
        String input = "C004\nAnother User\n1010101010\nSomeLocation\n";
        provideInput(input);

        when(mockCustomerDao.getCustomerById("C004")).thenReturn(null);
        when(mockCustomerDao.addCustomer(any(CustomerDetails.class))).thenReturn(false); // DAO fails

        CustomerDetails result = customerService.addCustomer();
        // The method prints "Failed to add customer." but still returns the object.
        assertNotNull(result); 
        assertEquals("C004", result.getCustomerId());
        verify(mockCustomerDao).addCustomer(any(CustomerDetails.class));
    }


    @Test
    void updateCustomer_customerExists_success() {
        String customerIdToUpdate = "C001";
        // Simulate scanner inputs for name, mobile, location
        String simulatedInput = "Alice Updated\n1112223331\nNew Location\n";
        provideInput(simulatedInput); // This sets System.in for the service's Scanner

        when(mockCustomerDao.getCustomerById(customerIdToUpdate)).thenReturn(customer1);
        when(mockCustomerDao.updateCustomer(any(CustomerDetails.class))).thenReturn(true);

        // CustomerService.updateCustomer takes customerId, then reads from its own Scanner
        customerService.updateCustomer(customerIdToUpdate);

        verify(mockCustomerDao, times(1)).getCustomerById(customerIdToUpdate);
        verify(mockCustomerDao, times(1)).updateCustomer(argThat(c ->
                c.getCustomerId().equals(customerIdToUpdate) &&
                c.getCustomerName().equals("Alice Updated") &&
                c.getMobileNumber().equals("1112223331") &&
                c.getCustomerLocation().equals("New Location")
        ));
    }

    @Test
    void updateCustomer_customerNotFound() {
        String customerIdToUpdate = "C_NON_EXIST";
        provideInput(""); // No further input needed if customer not found

        when(mockCustomerDao.getCustomerById(customerIdToUpdate)).thenReturn(null);

        customerService.updateCustomer(customerIdToUpdate);

        verify(mockCustomerDao, times(1)).getCustomerById(customerIdToUpdate);
        verify(mockCustomerDao, never()).updateCustomer(any(CustomerDetails.class));
        // Assert System.out captured "Customer not found." if possible, or just verify no update attempt.
    }
    
    @Test
    void updateCustomer_daoFailsToUpdate() {
        String customerIdToUpdate = "C001";
        String simulatedInput = "Alice Updated\n1112223331\nNew Location\n";
        provideInput(simulatedInput);

        when(mockCustomerDao.getCustomerById(customerIdToUpdate)).thenReturn(customer1);
        when(mockCustomerDao.updateCustomer(any(CustomerDetails.class))).thenReturn(false); // DAO fails

        customerService.updateCustomer(customerIdToUpdate);
        
        verify(mockCustomerDao).updateCustomer(any(CustomerDetails.class));
        // Assert System.out captured "Update failed."
    }


    @Test
    void deleteCustomer_success() {
        String customerIdToDelete = "C001";
        when(mockCustomerDao.deleteCustomer(customerIdToDelete)).thenReturn(true);

        customerService.deleteCustomer(customerIdToDelete);

        verify(mockCustomerDao, times(1)).deleteCustomer(customerIdToDelete);
        // Assert System.out captured "Customer deleted."
    }

    @Test
    void deleteCustomer_failureOrNotFound() {
        String customerIdToDelete = "C_NON_EXIST";
        when(mockCustomerDao.deleteCustomer(customerIdToDelete)).thenReturn(false);

        customerService.deleteCustomer(customerIdToDelete);

        verify(mockCustomerDao, times(1)).deleteCustomer(customerIdToDelete);
        // Assert System.out captured "Failed to delete or customer not found."
    }


    @Test
    void getAllCustomers_returnsListFromDao() {
        List<CustomerDetails> expectedCustomers = Arrays.asList(customer1, customer2);
        when(mockCustomerDao.getAllCustomers()).thenReturn(expectedCustomers);

        List<CustomerDetails> actualCustomers = customerService.getAllCustomers();

        assertEquals(expectedCustomers, actualCustomers);
        verify(mockCustomerDao, times(1)).getAllCustomers();
    }

    @Test
    void getCustomerById_returnsCustomerFromDao() {
        String customerId = "C001";
        when(mockCustomerDao.getCustomerById(customerId)).thenReturn(customer1);

        CustomerDetails actualCustomer = customerService.getCustomerById(customerId);

        assertEquals(customer1, actualCustomer);
        verify(mockCustomerDao, times(1)).getCustomerById(customerId);
    }
    
    @Test
    void getCustomerById_returnsNullIfDaoReturnsNull() {
        String customerId = "C_NON_EXIST";
        when(mockCustomerDao.getCustomerById(customerId)).thenReturn(null);

        CustomerDetails actualCustomer = customerService.getCustomerById(customerId);

        assertNull(actualCustomer);
        verify(mockCustomerDao, times(1)).getCustomerById(customerId);
    }
}